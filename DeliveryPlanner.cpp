//
//  DeliveryPlanner.cpp
//  GooberEats
//
//  Created by Sarah Liang on 3/5/20.
//  Copyright Â© 2020 Sarah Liang. All rights reserved.
//

#include "DeliveryPlanner.h"
#include <vector>
#include <string>

// returns cardinal direction of an angle
std::string DeliveryPlanner:: getDirection(double angle) const{
    if (angle>=0 && angle<22.5) {
        return "east";
    }
    if (angle>=22.5 && angle<67.5) {
        return "northeast";
    }
    if (angle>=67.5 && angle<112.5) {
        return "north";
    }
    if (angle>=112.5 && angle<157.5) {
        return "northwest";
    }
    if (angle>=157.5 && angle<202.5) {
        return "west";
    }
    if (angle>=202.5 && angle<247.5) {
        return "southwest";
    }
    if (angle>=247.5 && angle<292.5) {
        return "south";
    }
    if (angle>=292.5 && angle<337.5) {
        return "southeast";
    }
    return "east";
}

// fills commands vector with all necessary delivery commands to complete all deliveries
DeliveryResult DeliveryPlanner::generateDeliveryPlan(const GeoCoord& depot, const vector<DeliveryRequest>& deliveries, vector<DeliveryCommand>& commands, double& totalDistanceTravelled) const
{
    // reorder the order of the delivery requests (using the DeliveryOptimizer class) to optimize/reduce the total travel distance
    double oldDistance, newDistance;
    const GeoCoord* deliveryLocation;
    const GeoCoord*  startingPoint = &depot;
    std::list<StreetSegment> route;
    std::list<StreetSegment> ::iterator it;
    std::string streetName;
    std::string direction;
    double distance;
    int routeSize;
    DeliveryCommand instruction;
    totalDistanceTravelled = 0;
    vector<DeliveryRequest> reorderedDeliveries;
    
    for(int i =0; i<deliveries.size(); i++) {
        reorderedDeliveries.push_back(deliveries[i]);
    }
    
    DeliveryOpt.optimizeDeliveryOrder(depot, reorderedDeliveries, oldDistance, newDistance);
    std::cout<<"Old crow distance: "<<oldDistance<<endl<<"New crow distance: "<<newDistance<<endl;
    DeliveryRequest lastStop("depot", depot);
    reorderedDeliveries.push_back(lastStop);
    //Then generate point-to-point routes between the depot to each of the successive (optimized/reordered) delivery points, then back-to the depot after all the deliveries have been made (using the PointToPointRouter class)
    
    for(int i =0; i<reorderedDeliveries.size(); i++) {
        deliveryLocation = &reorderedDeliveries[i].location;
        DeliveryResult deliveryStatus = Router.generatePointToPointRoute(*startingPoint, *deliveryLocation,  route, distance);
        startingPoint = deliveryLocation;
        // if no success to that delivery location, delivery plan cannot be generated
        if(deliveryStatus != DELIVERY_SUCCESS){
            return deliveryStatus;
        }
        // for each set of point-to-point StreetSegments generated by PointToPointRouter in the previous step, generate a set of DeliveryCommands representing instructions to the delivery robot
        totalDistanceTravelled += distance;
        
        if(route.empty()){
            // delivering to depot
            instruction.initAsDeliverCommand(reorderedDeliveries[i].item);
            commands.push_back(instruction);
            continue;
        }
        
        // starting at the beginning of the route, create delivery commands until you are at the delivery location
        it = route.begin();
        streetName = it->name;
        direction = getDirection(angleOfLine(*it));
        distance = distanceEarthMiles(it->start, it->end);
        routeSize = route.size();
        instruction.initAsProceedCommand(direction, streetName, distance);
        commands.push_back(instruction);
        it--;
        
        while(!(routeSize==0)) {
            routeSize--;
            StreetSegment nextSeg = *(++it);
            // at end of route, break
            if ((it)==route.end()) {
                break;
            }
            it--;
            
            bool sameStreet = commands.back().streetName() == nextSeg.name;
            // if you travel straight or are going on the same street, create proceed command or add distance to existing one
            if (angleBetween2Lines(*it, nextSeg)<1 || angleBetween2Lines(*it, nextSeg)>359 || sameStreet) {
                streetName = nextSeg.name;
                instruction.initAsTurnCommand("null",streetName );
                
                direction = getDirection(angleOfLine(*it));
                distance = distanceEarthMiles(nextSeg.start, nextSeg.end);
                if(sameStreet){
                    commands.back().increaseDistance(distance);
                }
                else {
                    DeliveryCommand dc;
                    dc.initAsProceedCommand(direction, streetName, distance);
                    commands.push_back(dc);
                }
            }
            else { // you must turn
                streetName = nextSeg.name;
                if ((angleBetween2Lines(*it, nextSeg)>=1 && angleBetween2Lines(*it, nextSeg)<180 )) {
                    //if the angle between two lines is between 1 and 180, create turn left command
                    instruction.initAsTurnCommand("left", streetName);
                } else {
                    //if the angle between two lines is between 180 and 360, create turn right command
                    instruction.initAsTurnCommand("right", streetName);
                }
                
                commands.push_back(instruction);
                //turn the cardinal direction of the next line segment
                direction = getDirection(angleOfLine(nextSeg));
                distance = distanceEarthMiles(nextSeg.start, nextSeg.end);
                
                //proceed on the next street
                std::string streetName = nextSeg.name;
                instruction.initAsProceedCommand(direction, streetName, distance);
                commands.push_back(instruction);
            }
            it++;
        }
        // generate a deliver DeliveryCommand indicating that a food item should be delivered to that location
        if (i!= reorderedDeliveries.size()-1) {
            instruction.initAsDeliverCommand(reorderedDeliveries[i].item);
            commands.push_back(instruction);
        }
    }
    return DELIVERY_SUCCESS;
}

